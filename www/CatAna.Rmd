---
title: "CatAna"
output:
  word_document:
    highlight: "tango"
    
params:
    data: NA
    fv1: NA
    fv2: NA
    typeBar: NA
    displayWithPie: NA
    repDataSetInput: NA
    obs: !r c(5)
    factor: NA
    dataInput: NA
    numCounts: !r c("100,200,55,75")
    numColumn: !r c(2)
    numRow: !r c(2)
    fv3: NA
    fv3a: NA
    selectionLoglin: !r c("1")
    numSuccess: !r c("35,41")
    numTotal: !r c("53,72")
    pNull: !r c("0.5,0.5")
    pAlter: !r c("two.sided")
    pConf: !r c(0.95)
    pCorrect: !r c(FALSE)
    numSuccess1: !r c(35)
    numTotal1: !r c(53)
    pNull1: !r c(0.5)
    pAlter1: !r c("two.sided")
    pConf1: !r c(0.95)
    name: NA
    text_graphcat1: NA
    text_graphcat2: NA
    text_graphcat3: NA
    text_graphcat4: NA
    text_graphcat5: NA
    text_graphcat6: NA
    text_graphcat7: NA
    text_tablecat1: NA
    text_tablecat2: NA
    text_tablecat3: NA
    text_tablecat4: NA
    text_tablecat5: NA
    text_infercat1: NA
    text_infercat2: NA
    text_infercat3: NA
    text_infercat4: NA
    text_infercat5: NA
    text_infercat6: NA
    text_infercat7: NA
---


```{r library, echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
library(shiny)
library(shinydashboard)
library(vcd)
library(car)
library(lattice)
library(aplpack)
library(psych)
library(MASS)
library(ca)

library(kableExtra)
library(knitr)
library(tidyr)
library(formattable)
```


```{r DataImport, echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
dataRep <- params$data

```

Author: `r params$name`

Date: `r strftime(Sys.Date(), format = "%Y-%b-%d")`


# Graphs

## Bar chart

A bar chart is a graphical representation of the distribution of qualitative data (i.e. categorical variable).

```{r echo=FALSE, warning=FALSE, error=FALSE, message=FALSE, fig.align='center', fig.width=5, fig.height=5}

dataFac <- dataRep

repBarPlot <- function(){
  
  if(length(dataFac) == 0 || is.null(dataFac)){
    out <- paste("NOTE: There are no categorical variables in the selected dataset.")
    return(out)
  }
  
  if(ncol(dataFac) == 1){
    counts <- table(dataFac[,params$fv1])
    return(barplot(counts, xlab=paste(params$fv1), ylab="Frequency", main=paste("Distribution by", params$fv1)) )
  }
  
  if(is.null(params$typeBar)){
    typeBar <- "plainBar"
  } else {
    typeBar <- params$typeBar 
  }
  
  if(typeBar == "groupedBar") #Grouped bar chart
  {
    counts <- table(dataFac[,params$fv1], dataFac[, params$fv2])
    return(barplot(counts, xlab=paste(params$fv2), ylab="Frequency", legend = rownames(counts), beside=TRUE, main=paste("Distribution by", params$fv1, "and", params$fv2)) )
  }
  
  if(typeBar == "stackedBar") #Stacked bar chart
  {
    counts <- table(dataFac[,params$fv1], dataFac[, params$fv2])
    return(barplot(counts, xlab=paste(params$fv2), ylab="Frequency", legend = rownames(counts), main=paste("Distribution by", params$fv1, "and", params$fv2)) )
  }
  
  if(typeBar == "plainBar") # Not grouped bar chart
  {
    counts <- table(dataFac[,params$fv1])
    return(barplot(counts, xlab=paste(params$fv1), ylab="Frequency", main=paste("Distribution by", params$fv1)) )	
  }
}

repBarPlot()

```

#### Interpretation
`r params$text_graphcat1`


## Dotplot

A dotplot is a type of graphic display used to compare frequency counts within categories or groups.

```{r echo=FALSE, warning=FALSE, error=FALSE, message=FALSE, fig.align='center', fig.width=5, fig.height=5}
dataFac <- dataRep

if(ncol(dataFac) == 1) 
{
  myTable <- table(dataFac[,params$fv1])
  dotplot(myTable, groups=FALSE, type=c("p", "h"), xlab="Frequency", 
          prepanel = function (x, y) {
            list(ylim = levels(reorder(y, x)))
          }, 
          panel = function(x, y, ...){
            panel.dotplot(x, reorder(y,x), ...)
          }) 
} else {
  myTable <- table(dataFac[,params$fv1], dataFac[,params$fv2])
  dotplot(myTable, groups=FALSE, layout = c(1, length(levels(dataFac[,params$fv2]))), auto.key=list(lines=TRUE), type=c("p", "h"), xlab="Frequency",
          prepanel = function (x, y) {
            list(ylim = levels(reorder(y, x)))
          }, 
          panel = function(x, y, ...){
            panel.dotplot(x, reorder(y,x), ...)
          })
}

```

#### Interpretation
`r params$text_graphcat2`

## Pie chart

Pie chart is a graphical technique for presenting relative frequencies associated with the observed values of a categorical variable.

```{r PieChart, echo=FALSE, warning=FALSE, error=FALSE, message=FALSE, fig.align='center', fig.width=5, fig.height=5}
dataFac <- dataRep

if(is.null(params$displayWithPie)) {
  displayWithPie <- "justLabel"
} else {
  displayWithPie <- params$displayWithPie
}

if(displayWithPie == "sampleSizePie")
{
  myTable <- table(dataFac[,params$fv1])
  labs<- paste(names(myTable), "\n", myTable, sep="")
  pie(myTable, labels=labs, col=rainbow(length(levels(dataFac[,params$fv1]))), main=paste("Pie chart of", paste(params$fv1), "\n (with number in the slice)"))
}	else {
  if(displayWithPie == "percentPie")
  {
    myTable <- table(dataFac[,params$fv1])
    percentlabels<- round(100*myTable/sum(myTable), 1)
    labs<- paste(names(myTable), "\n", percentlabels, "%", sep="")
    pie(myTable, labels=labs, col=rainbow(length(levels(dataFac[,params$fv1]))), main=paste("Pie chart of", paste(params$fv1), "\n (with percentage)"))
  }	else {
    if(displayWithPie == "justLabel") 
    {
      myTable <- table(dataFac[,params$fv1])
      labs<- paste(names(myTable))
      pie(myTable, labels=labs, col=rainbow(length(levels(dataFac[,params$fv1]))), main=paste("Pie chart of", paste(params$fv1)))
    }
  }
}



```

#### Interpretation
`r params$text_graphcat3`

## Mosaic plot

A mosaic plot is a graphical display that allows examination of the relationship among two or more categorical variables.

```{r echo=FALSE, warning=FALSE, error=FALSE, message=FALSE, fig.align='center', fig.width=5, fig.height=5}
dataFac <- dataRep

repMosaicPlot <- function(){
  if((length(dataFac) == 0 || is.null(dataFac)) || ncol(dataFac)<=1){
    out <- paste("NOTE: At least two categorical variables are required for a mosaic plot.")
    return(out)
  }else{
    xvector <- as.vector(dataFac[,params$fv1])
    yvector <- as.vector(dataFac[,params$fv2])
    long.labels <- list(set_varnames = c(xvector=params$fv1, yvector=params$fv2))
    myTable <- table(xvector, yvector)
    return(mosaic(myTable, legend=TRUE, shade=TRUE, las=2, col=TRUE, cex.axis=0.5, labeling_args = long.labels))
  }
}

repMosaicPlot()

```

#### Interpretation
`r params$text_graphcat4`

## Association plot

An association plot indicates deviations from a specified independence model in a possibly high-dimensional contingency table

```{r echo=FALSE, warning=FALSE, error=FALSE, message=FALSE, fig.align='center', fig.width=5, fig.height=5}
dataFac <- dataRep

repAssocPlot <- function(){
  if((length(dataFac) == 0 || is.null(dataFac)) || ncol(dataFac)<=1){
    out <- paste("NOTE: At least two categorical variables are required for an association plot.")
    return(out)
  }else{
    xvector <- as.vector(dataFac[,params$fv1])
    yvector <- as.vector(dataFac[,params$fv2])
    long.labels <- list(set_varnames = c(xvector=params$fv1, yvector=params$fv2))
    myTable <- table(xvector, yvector)
    return(assoc(myTable, legend=TRUE, shade=TRUE, col=TRUE, cex.axis=0.5, labeling_args = long.labels))
  }
}

repAssocPlot()

```

#### Interpretation
`r params$text_graphcat5`

## Agreement plot

An agreement plot provides a simple graphic representation of the strength of agreement in a contingency table, and a measure of strength of agreement with an intuitive interpretation.

```{r Agreement, echo=FALSE, warning=FALSE, error=FALSE, message=FALSE, fig.align='center', fig.width=5, fig.height=5}
dataFac <- dataRep

repAgreementPlot <- function(){
  if(((length(dataFac) == 0 || is.null(dataFac)) || ncol(dataFac)<=1) || levels(dataFac[,params$fv1]) != levels(dataFac[,params$fv2])) {
    out <- paste("NOTE: At least two categorical variables are required for an agreement plot and both categorical variables should have the same number of categories. For instance, two raters answered the question with three possible answers: Agree, Neutral and Disagree.")
    return(out)
    
  }else{
    xvector <- as.vector(dataFac[,params$fv1])
    yvector <- as.vector(dataFac[,params$fv2])
    #long.labels <- list(set_varnames = c(xvector=input$fv1, yvector=input$fv2))
    myTable <- table(xvector, yvector)
    return(agreementplot(myTable, xlab=params$fv1, ylab=params$fv2))
  }
}

repAgreementPlot()


```

#### Interpretation
`r params$text_graphcat6`


## Correspondence plot

Graphical display of the relationship between categorical variables in a type of scatterplot diagram.

```{r Correspondence, echo=FALSE, warning=FALSE, error=FALSE, message=FALSE, fig.align='center', fig.width=5, fig.height=5}
dataFac <- dataRep

repCorrespondencePlot <- function(){
  if((length(dataFac) == 0 || is.null(dataFac)) || ncol(dataFac)<=1 || min(length(levels(dataFac[,params$fv1])), length(levels(dataFac[,params$fv2])))<=2) {
    out <- paste("NOTE: At least two categorical variables are required for a correspondence analysis plot. Also,  each of the categorical variable must have at least three categories. ")
    return(out)
  }
  
  if((length(dataFac) == 0 || is.null(dataFac)) || ncol(dataFac)<=1 || min(length(levels(dataFac[,params$fv1])), length(levels(dataFac[,params$fv2])))<=2) {
    out <- paste("NOTE: At least two categorical variables are required for a correspondence analysis. Also,  each of the categorical variable must have at least three categories. ")
    return(out)
  }
  
  xvector <- as.vector(dataFac[,params$fv1])
  yvector <- as.vector(dataFac[,params$fv2])
  myTable <- table(xvector, yvector)
  return(plot(ca(myTable, nd=ncol(myTable))))
  
}

repCorrespondencePlot()


```

#### Interpretation
`r params$text_graphcat7`

# Tables

## Dataset

```{r echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
datasetInput <- params$repDataSetInput

if(!is.null(datasetInput)){
  out <- head(datasetInput, n=params$obs)
  #kable(out, format = "html", digits = 2, format.args = list(nsmall = 2)) %>% kable_styling(full_width = F, position = "left")
  kable(out)
  
} else {
  return(NULL)
}
```

#### Interpretation
`r params$text_tablecat1`

## Descriptive statistics

We summarise categorical variable basically by counting occurrences to give us a frequency. If the categories are coded then the psych package provides also mean values and standard deviations.

### Print summary statistics (base)

```{r echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
dataFac <- dataRep

if(!is.null(dataFac)){
  dataset <- dataFac
  out <- summary(dataset)
  return(out)
} else {
  out <- NULL
  return(out)
}

```

### Print summary statistics by factor (psych)

```{r psych, echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
dataFac <- dataRep

if(is.null(params$factor)) {
  fac <- FALSE
} else {
  fac <- params$factor
}

if(length(dataFac) == 0 | is.null(dataFac)) {
  out <- paste("NOTE: There are no numeric variables in the selected dataset.")
  return(out)
}	else {
  if(fac == FALSE){
    dataset <- dataFac
    out <- describe(dataset, skew=FALSE, ranges=FALSE)
    return(out)
  } else {
    dataset <- dataFac
    out <- describeBy(dataset, group=dataFac[,params$fv1], skew=FALSE, ranges=FALSE)
    return(out)
  }
}

```

#### Interpretation
`r params$text_tablecat2`

## Frequency tables

We summarise categorical variable by counting up frequencies and by counting occurrences to give us proportions and percentages.

### Frequency table

```{r echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
dataFac <- dataRep

if(ncol(dataFac)>1){
  out <- table(dataFac[,params$fv1], dataFac[,params$fv2])
  
  out <- as.data.frame(out)
  out <- spread(out, Var2, Freq)
  rwn <- out$Var1
  out <- out[,-1]
  rownames(out) <- rwn
  
  #kable(out, format = "html", digits = 2, format.args = list(nsmall = 2)) %>% kable_styling(full_width = F, position = "left")
  kable(out)
  
} else {
  cTable <- as.data.frame(table(dataFac[,params$fv1]))
  names(cTable)[1] = params$fv1
  out <- cTable
  
  #kable(out, format = "html", digits = 2, format.args = list(nsmall = 2)) %>% kable_styling(full_width = F, position = "left")
  kable(out)
}
```

### Cell percentages

```{r echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
dataFac <- dataRep

if(ncol(dataFac)>1){
  myTable <- table(dataFac[,params$fv1], dataFac[,params$fv2])
  out <- prop.table(myTable)
  
  out <- as.data.frame(out)
  out <- spread(out, Var2, Freq)
  rwn <- out$Var1
  out <- out[,-1]
  rownames(out) <- rwn
  
  #kable(out, format = "html", digits = 2, format.args = list(nsmall = 2)) %>% kable_styling(full_width = F, position = "left")
  kable(out, digits = 2, format.args = list(nsmall = 2))
  
} else {
  myTable <- table(dataFac[,params$fv1])
  cTable <- as.data.frame(prop.table(myTable))
  names(cTable)[1] = params$fv1
  out <- cTable
  
  #kable(out, format = "html", digits = 2, format.args = list(nsmall = 2)) %>% kable_styling(full_width = F, position = "left")
  kable(out, digits = 2, format.args = list(nsmall = 2))
}
```

### Expected frequencies

```{r echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
dataFac <- dataRep

if(ncol(dataFac)>1){
  myTable <- table(dataFac[,params$fv1], dataFac[,params$fv2])
  out <- independence_table(myTable)
  #kable(out, format = "html", digits = 2, format.args = list(nsmall = 2)) %>% kable_styling(full_width = F, position = "left")
  kable(out, digits = 2, format.args = list(nsmall = 2))
  
} else {
  myTable <- as.data.frame(table(dataFac[,params$fv1]))
  names(myTable)[1] = params$fv1
  out <- independence_table(myTable)
  #kable(out, format = "html", digits = 2, format.args = list(nsmall = 2)) %>% kable_styling(full_width = F, position = "left")
  kable(out, digits = 2, format.args = list(nsmall = 2))
}
```

### Expected frequencies (relative)

```{r echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
dataFac <- dataRep

if(ncol(dataFac)>1){
  myTable <- table(dataFac[,params$fv1], dataFac[,params$fv2])
  out <- independence_table(myTable, frequency = c("relative"))
  #kable(out, format = "html", digits = 2, format.args = list(nsmall = 2)) %>% kable_styling(full_width = F, position = "left")
  kable(out, digits = 2, format.args = list(nsmall = 2))
  
} else {
  myTable <- table(dataFac[,params$fv1])
  cTable <- as.data.frame(prop.table(myTable))
  names(cTable)[1] = params$fv1
  out <- independence_table(cTable, frequency = c("relative"))
  #kable(out, format = "html", digits = 2, format.args = list(nsmall = 2)) %>% kable_styling(full_width = F, position = "left")
  kable(out, digits = 2, format.args = list(nsmall = 2))
}
```

### Marginal frequencies (1st variable) 

```{r echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
dataFac <- dataRep

if(ncol(dataFac)>1){
  myTable <- table(dataFac[,params$fv1], dataFac[,params$fv2])
  cTable <- margin.table(myTable, 1)
  dfTable <- as.data.frame(cTable)
  names(dfTable)[1] = params$fv1
  out <- dfTable
  #kable(out, format = "html", digits = 2, format.args = list(nsmall = 2)) %>% kable_styling(full_width = F, position = "left")
  kable(out)
  
} else {
  out <- NULL 
}
```

### Marginal frequencies (2nd variable)

```{r echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
if(ncol(dataFac)>1){
  myTable <- table(dataFac[,params$fv1], dataFac[,params$fv2])
  cTable <- margin.table(myTable, 2)
  dfTable <- as.data.frame(cTable)
  names(dfTable)[1] = params$fv2
  out <- dfTable
  #kable(out, format = "html", digits = 2, format.args = list(nsmall = 2)) %>% kable_styling(full_width = F, position = "left")
  kable(out)
  
} else {
  out <- NULL 
}
```

### Marginal percentages (1st variable)

```{r echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
if(ncol(dataFac)>1){
  myTable <- table(dataFac[,params$fv1], dataFac[,params$fv2])
  cTable <- margin.table(myTable, 1)
  dfTable <- as.data.frame(prop.table(cTable))
  names(dfTable)[1] = params$fv1
  out <- dfTable
  #kable(out, format = "html", digits = 2, format.args = list(nsmall = 2)) %>% kable_styling(full_width = F, position = "left")
  kable(out, digits = 2, format.args = list(nsmall = 2))
  
} else {
  out <- NULL 
}

```

### Marginal percentages (2nd variable)

```{r echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
if(ncol(dataFac)>1){
  myTable <- table(dataFac[,params$fv1], dataFac[,params$fv2])
  cTable <- margin.table(myTable, 2)
  dfTable <- as.data.frame(prop.table(cTable))
  names(dfTable)[1] = params$fv2
  out <- dfTable
  #kable(out, format = "html", digits = 2, format.args = list(nsmall = 2)) %>% kable_styling(full_width = F, position = "left")
  kable(out, digits = 2, format.args = list(nsmall = 2))
  
} else {
  out <- NULL 
}
```

### Row percentages

```{r echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
if(ncol(dataFac)>1){
  myTable <- table(dataFac[,params$fv1], dataFac[,params$fv2])
  out <- prop.table(myTable, 1)
  
  out <- as.data.frame(out)
  out <- spread(out, Var2, Freq)
  rwn <- out$Var1
  out <- out[,-1]
  rownames(out) <- rwn
  
  #kable(out, format = "html", digits = 2, format.args = list(nsmall = 2)) %>% kable_styling(full_width = F, position = "left")
  kable(out, digits = 2, format.args = list(nsmall = 2))
  
} else {
  out <- NULL 
}
```

### Column percentages

```{r echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
if(ncol(dataFac)>1){
  myTable <- table(dataFac[,params$fv1], dataFac[,params$fv2])
  out <- prop.table(myTable, 2)
  
  out <- as.data.frame(out)
  out <- spread(out, Var2, Freq)
  rwn <- out$Var1
  out <- out[,-1]
  rownames(out) <- rwn
  
  #kable(out, format = "html", digits = 2, format.args = list(nsmall = 2)) %>% kable_styling(full_width = F, position = "left")
  kable(out, digits = 2, format.args = list(nsmall = 2))
  
} else {
  out <- NULL 
}
```

#### Interpretation
`r params$text_tablecat3`


## Association Statistics

Computes the Pearson chi-squared test, the likelihood ratio chi-squared test, the phi coefficient, the contingency coefficient and Cramer's V.

```{r echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
xvector <- as.vector(dataFac[,params$fv1])
yvector <- as.vector(dataFac[,params$fv2])
myTable <- table(xvector, yvector)
out <- summary(assocstats(myTable))
return(out)
```

#### Interpretation
`r params$text_tablecat4`

## Correspondence analysis

Correspondence analysis is one of a wide range of alternative ways of handling and representing the relationships between categorical data.

```{r echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
if(length(levels(dataFac[,params$fv1]))<=2 || length(levels(dataFac[,params$fv1]))<=2) {
  out <- NULL
} else {
  xvector <- as.vector(dataFac[,params$fv1])
  yvector <- as.vector(dataFac[,params$fv2])
  
  myTable <- table(xvector, yvector)
  print(ca(myTable, nd=ncol(myTable)))
}

```

#### Interpretation
`r params$text_tablecat5`

# Inference

## Chi-squared test (raw data) 

The chi-squared test is used to test independence of the row and column variables in the two-way/contingency tables.

```{r echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
if(ncol(dataFac)<=1){
  out <- NULL
} else {
  conTbl <- table(dataFac[,params$fv1], dataFac[,params$fv2])
  test <- chisq.test(conTbl)
  test$data.name <- paste(params$fv1, "and", params$fv2, "variables from", params$dataInput, "dataset")
  out <- test
  return(out)
}
```

#### Interpretation
`r params$text_infercat1`

## Chi-squared test (aggregated data)

The chi-squared test is used to test independence of the row and column variables in the two-way/contingency tables.

```{r echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
############################
# Two-way table aggregated
############################
aggTable <- function(){
  numFreq <- as.numeric(unlist(strsplit(as.character(params$numCounts), split=",")))
  aggTable <- matrix(numFreq, ncol=params$numColumn, nrow=params$numRow, byrow=TRUE)
  out <- as.table(aggTable)
  return(out)
}

# ###################################
#  Chi-squared test (aggregated data)
# ###################################
out <- summary(aggTable())
return(out)

```


### Expected frequencies
```{r echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
out <- independence_table(aggTable())
#kable(out, format = "html", digits = 2, format.args = list(nsmall = 2)) %>% kable_styling(full_width = F, position = "left")
kable(out, digits = 2, format.args = list(nsmall = 2))

```


### Expected frequencies (relative)
```{r echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
out <- independence_table(aggTable(), frequency = c("relative"))
#kable(out, format = "html", digits = 2, format.args = list(nsmall = 2)) %>% kable_styling(full_width = F, position = "left")
kable(out, digits = 2, format.args = list(nsmall = 2))

```

#### Interpretation
`r params$text_infercat2`


## Fisher's exact test

Fisher's exact test provides an exact test of independence of the row and column variables in the two-way/contingency tables.

```{r echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
if((length(dataFac) == 0 || is.null(dataFac)) || ncol(dataFac)<=1){
  out <- NULL
} else {
  if(length(levels(dataFac[,params$fv1]))+length(levels(dataFac[,params$fv2]))>6) {
    out <- NULL
  } else {
    conTbl <- table(dataFac[,params$fv1], dataFac[,params$fv2])
    test <- fisher.test(conTbl, conf.int = TRUE, conf.level = 0.95, workspace=2e+6, hybrid=TRUE)
    test$data.name <- paste(params$fv1, "and", params$fv2, "variables from", params$dataInput, "dataset")
    out <- test
    return(out)
  }
}

```

#### Interpretation
`r params$text_infercat3`

## Mantel-Haenszel test

Mantel-Haenszel chi-squared test is used to test the null hypothesis that two nominal variables are conditionally independent in each stratum.

```{r echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
if(is.null(params$fv3)) {
  fv3 <- params$fv2
} else {
  fv3 <- params$fv3
}


if((length(dataFac) == 0 || is.null(dataFac)) || ncol(dataFac)<=2 || is.null(params$fv1)){
  out <- NULL
}	else {
  if(length(levels(dataFac[,params$fv1]))<2 || length(levels(dataFac[,params$fv2]))<2 || length(levels(dataFac[,fv3]))<2 || params$fv1 == params$fv2 || params$fv1 == fv3 || params$fv2 == fv3) {
    out <- NULL
  } else {
    conTbl <- table(dataFac[,params$fv1], dataFac[,params$fv2], dataFac[,fv3])
    test <- mantelhaen.test(conTbl, conf.level = 0.95)
    test$data.name <- paste(params$fv1, "and", params$fv2, "variables and strata", fv3, "from", params$dataInput, "dataset")
    out <- test
    return(out)
  }
}

```

#### Interpretation
`r params$text_infercat4`

## Log-linear model tests

For a log-linear models based on a three-dimensional contingency tables the following tests are performed: mutual, partial, and conditional independence and no three-way interaction.

```{r loglinear, echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}

if((length(dataFac) == 0 || is.null(dataFac)) || ncol(dataFac)<=2){
  out <- NULL
} else	{
  
  A <- dataFac[,params$fv1]
  B <- dataFac[,params$fv2]
  if(is.null(params$fv3a)) {
    C <- dataFac[,1]
  } else {
    C <- dataFac[,params$fv3a]
  }
  dat <- cbind(A,B,C)
  s <- params$selectionLoglin
  mytable <- xtabs(~A+B+C, data=dat)
  if(params$selectionLoglin == "1") {out <- loglm(~A+B+C, mytable)}
  else if(params$selectionLoglin == "2") {out <- loglm(~A+B+C+B*C, mytable)}
  else if(params$selectionLoglin == "3") {out <- loglm(~A+B+C+A*C+B*C, mytable)}
  else if(params$selectionLoglin == "4") {out <- loglm(~A+B+C+A*B+A*C+B*C, mytable)}
}
return(out)
```

#### Interpretation
`r params$text_infercat5`

## Test of equal or given proportions

Performs the test for testing the null hypothesis that the proportions (probabilities of success) in several groups are the same, or that they equal certain given values.

```{r echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}

Success <- as.numeric(unlist(strsplit(as.character(params$numSuccess), split=",")))
Total <- as.numeric(unlist(strsplit(as.character(params$numTotal), split=",")))
Pnull <- as.numeric(unlist(strsplit(as.character(params$pNull), split=",")))
if(all(Success<Total) && length(Success) == length(Total) && length(Success) == length(Pnull) && length(Total) == length(Pnull) && length(Success)!=2){
  test <- prop.test(Success, Total, Pnull, alternative=params$pAlter, conf.level=params$pConf, correct=params$pCorrect)
} else { 
  if(length(Success)==2 && length(Total)==2) {test <- prop.test(Success, Total, alternative=params$pAlter, conf.level=params$pConf, correct=params$pCorrect)
  } else {
    test <- NULL
  }
}
return(test)
```

#### Interpretation
`r params$text_infercat6`

## Binomial test

Performs an exact test of a simple null hypothesis about the probability of success in a Bernoulli experiment.

```{r echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
Success <- params$numSuccess1
Total <-  params$numTotal1
if(Success<Total) { 
  test <- binom.test(Success, Total, params$pNull1, alternative=params$pAlter1, conf.level=params$pConf1)
} else {
  test <- NULL
}
return(test)

```

#### Interpretation
`r params$text_infercat7`
